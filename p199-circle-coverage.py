#   New circles always make three new gaps#   Each gap can be defined by the three circles that surround it. One of these circles may be the outer circle.# Soddy Circles / Descartes' Theorem is the name of the game here.import pygletfrom pyglet.window import mousefrom pyglet.window import keyfrom pyglet.gl import *from math import pi, sin, cos, sqrt, degrees, radians, fabsdef drawLine((xfrom, yfrom), (xto, yto)):    pyglet.graphics.draw(2, pyglet.gl.GL_LINES,('v2f', (xfrom,yfrom,xto,yto)))def drawCircle(x,y,r,steps=300,hollow=True):    type = pyglet.gl.GL_LINE_LOOP if hollow else pyglet.gl.GL_POLYGON    glBegin(type);    increment = (2*pi)/steps    for i in xrange(steps):       glVertex2f(x+cos(i*increment)*r,y+sin(i*increment)*r);    glEnd();   def sign(n):    if n == 0.0:        return 1.0    else:        return n / fabs(n)        def feq(a,b):   return a - 0.1 < b < a + 0.1   def outer_soddy_position(c1, c2, c3, r4):    k1, k2, k3 = -1.0/c1.r, 1.0/c2.r, 1.0/c3.r    z1, z2, z3 = complex(c1.x, c1.y), complex(c2.x, c2.y), complex(c3.x, c3.y)    neg_result = r4 * (z1*k1 + z2*k2 + z3*k3 - 2 * complex_sqrt(z1*k1*z2*k2 + z1*k1*z3*k3 + z2*k2*z3*k3))    pos_result = r4 * (z1*k1 + z2*k2 + z3*k3 + 2 * complex_sqrt(z1*k1*z2*k2 + z1*k1*z3*k3 + z2*k2*z3*k3))    # the correct result lies along a vector from the outer circle's center to the new circle's position - simplified here because the outer circle's center is always 0,0    dist_from_center = c1.r - r4    distances = {}    for candidate in [neg_result, pos_result]:        vl = sqrt(candidate.real * candidate.real + candidate.imag * candidate.imag)        vx, vy = candidate.real / vl, candidate.imag / vl        dist = sqrt(((vx * dist_from_center) - candidate.real) ** 2 + ((vy * dist_from_center) - candidate.imag) ** 2)        distances[dist] = candidate    return distances[min(distances.keys())]   def inner_soddy_position(c1, c2, c3, r4):    k1, k2, k3 = 1.0/c1.r, 1.0/c2.r, 1.0/c3.r    z1, z2, z3 = complex(c1.x, c1.y), complex(c2.x, c2.y), complex(c3.x, c3.y)    neg_result = r4 * (z1*k1 + z2*k2 + z3*k3 - 2 * complex_sqrt(z1*k1*z2*k2 + z1*k1*z3*k3 + z2*k2*z3*k3))    pos_result = r4 * (z1*k1 + z2*k2 + z3*k3 + 2 * complex_sqrt(z1*k1*z2*k2 + z1*k1*z3*k3 + z2*k2*z3*k3))    # the correct result lies along a vector from the outer circle's center to the new circle's position - simplified here because the outer circle's center is always 0,0    dist_from_center = c1.r + r4    distances = {}    for candidate in [neg_result, pos_result]:        dx, dy = candidate.real - c1.x, candidate.imag - c1.y        vl = sqrt(dx ** 2 + dy ** 2)        vx, vy = dx / vl, dy / vl        dist = sqrt(((vx * dist_from_center) - candidate.real) ** 2 + ((vy * dist_from_center) - candidate.imag) ** 2)        distances[dist] = candidate    return distances[min(distances.keys())]   def complex_sqrt(comp):    a,b = comp.real, comp.imag    if a == 0.0 and b == 0.0:        return complex(0,0)    p = (1.0/sqrt(2)) * sqrt(sqrt(a*a + b*b) + a)    # inprecision abounds    q = sign(b)*(1.0/sqrt(2)) * sqrt(sqrt(a*a + b*b) - a)    return complex(p,q)   def outer_soddy_radius(r1, r2, r3):    return r1*r2*r3 / (r1*r2 + r1*r3 + r2*r3 - 2 * sqrt(r1*r2*r3*(r1+r2+r3)))    def inner_soddy_radius(r1, r2, r3):    return r1*r2*r3 / (r1*r2 + r1*r3 + r2*r3 + 2 * sqrt(r1*r2*r3*(r1+r2+r3)))window = pyglet.window.Window(caption = "euler 199", width=500, height=500)class Circle:    def __init__(self,x,y,r,color=(1.0, 1.0, 1.0)):        self.x, self.y, self.r = x,y,r        self.red, self.green, self.blue = color    def area(self):        return pi * self.r * self.r    def draw(self):        glColor3f(self.red, self.green, self.blue)        drawCircle(self.x, self.y, self.r)class Gap:    outer_circle = None    def __init__(self,c1,c2,c3):        special_circle = None        for circle in [c1, c2, c3]:            if circle == self.outer_circle:                special_circle = circle                break        if special_circle:            self.c1 = special_circle            all = [c1, c2, c3]            all.remove(special_circle)            self.c2, self.c3 = all[0], all[1]        else:            self.c1, self.c2, self.c3 = c1, c2, c3    def __repr__(self):        record = []        for circle in [self.c1, self.c2, self.c3]:            if circle == self.outer_circle:                record.append('outer circle')            else:                record.append(str(circle))        return ' '.join(record)    def subdivide(self, simple=False):        if self.c1 == self.outer_circle:            new_circle = place_border_circle(self.c1, self.c2, self.c3)        else:            new_circle = place_inner_circle(self.c1, self.c2, self.c3)        gaps = [Gap(new_circle, self.c1, self.c2), Gap(new_circle, self.c2, self.c3), Gap(new_circle, self.c1, self.c3)]        return new_circle, gaps# design the outermost circle to take up three circles of radius '1' - add the radius of the innermost soddy circlecenter_radius = inner_soddy_radius(1.0,1.0,1.0)outer_radius = 2 + center_radiusdist_to_circle = (1+center_radius)        outer_circle = Circle(0,0,outer_radius,(0.0,1.0,0.0))Gap.outer_circle = outer_circlecircle1, circle2, circle3 = Circle(0,-dist_to_circle,1), Circle(dist_to_circle*cos(radians(30)),dist_to_circle*sin(radians(30)),1), Circle(-dist_to_circle*cos(radians(30)),dist_to_circle*sin(radians(30)),1)circles = [circle1, circle2, circle3]gaps = [Gap(circle1, circle2, circle3), Gap(outer_circle, circle1, circle2), Gap(outer_circle, circle2, circle3), Gap(outer_circle, circle1, circle3)]       def place_inner_circle(c1, c2, c3, simple=False):    rad = inner_soddy_radius(c1.r, c2.r, c3.r)    if simple:        return Circle(0,0,rad)    hmm = inner_soddy_position(c1, c2, c3, rad)    return Circle(hmm.real, hmm.imag, rad)   def place_border_circle(circle_from, circle1, circle2, simple=False):    rad = outer_soddy_radius(-circle_from.r, circle1.r, circle2.r)    if simple:        return Circle(0,0,rad)    hmm = outer_soddy_position(circle_from, circle1, circle2, rad)    return Circle(hmm.real, hmm.imag, rad)      generated_circles = []working_gaps = gapsfor i in xrange(3):    new_gaps = []    for gap in working_gaps:        generated_circle, generated_gaps = gap.subdivide()        generated_circles.append(generated_circle)        new_gaps += generated_gaps    working_gaps = new_gapscovered = sum([circle.area() for circle in circles]) + sum([circle.area() for circle in generated_circles])print (outer_circle.area() - covered) / outer_circle.area()        memo = {}def get_covered_area(gap,n):    if n == 0:        return 0    memo_tuple = (gap.c1.r, gap.c2.r, gap.c3.r)    if memo_tuple in memo:        return memo[memo_tuple]    else:        generated_circle, generated_gaps = gap.subdivide(simple=True)        covered = generated_circle.area()        for new_gap in generated_gaps:            covered += get_covered_area(new_gap, n-1)        memo[memo_tuple] = covered        return coveredcovered = sum([get_covered_area(gap,10) for gap in gaps]) + sum([circle.area() for circle in circles])print (outer_circle.area() - covered) / outer_circle.area()        class G:    n_gap = 0         @window.eventdef on_key_press(symbol, modifiers):    if symbol == key.SPACE:        G.n_gap += 1         @window.eventdef on_draw():    window.clear()    #This shouldn't need to be here...    glMatrixMode(GL_PROJECTION)    glLoadIdentity()    glOrtho(-outer_radius, outer_radius, -outer_radius, outer_radius, -1, 1)    glMatrixMode(GL_MODELVIEW)        glColor3f(1.0,0.0,0.0)    outer_circle.draw()    [circle.draw() for circle in circles]    [circle.draw() for circle in generated_circles]    # questionable = gaps[G.n_gap]    # bad_circle, more_gaps = questionable.subdivide()    # for circle in [questionable.c1, questionable.c2, questionable.c3]:        # circle.draw()    # bad_circle.draw()    pyglet.app.run()