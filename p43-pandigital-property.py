# There's some speedups possible for this, if you consider that the only pandigitals you need to generate have the last 3 digits as multiples of 17# and 'bubble backwards' from there, throwing out non-pandigitals as you godef has_property(n):    strn = str(n)    if int(strn[1:4]) % 2 != 0:        return False    if int(strn[2:5]) % 3 != 0:        return False    if int(strn[3:6]) % 5 != 0:        return False    if int(strn[4:7]) % 7 != 0:        return False    if int(strn[5:8]) % 11 != 0:        return False    if int(strn[6:9]) % 13 != 0:        return False    if int(strn[7:10]) % 17 != 0:        return False    return Truedef swap(l, a, b):  temp = l[a];  l[a] = l[b];  l[b] = temp; # "SEPA algorithm" per a forums answer to p24def permute(str,len):  key = len-1  newkey = len-1  while ((key > 0) and (str[key] <= str[key-1])):    key -= 1  key -= 1  if (key < 0):    return 0  newkey = len-1  while ((newkey > key) and (str[newkey] <= str[key])):    newkey -= 1  swap(str,key,newkey)  len -= 1  key += 1  while(len>key):    swap(str,len,key)    key += 1    len -= 1  return 1def permutations(seq):  if len(seq) == 1:    yield seq  else:    for i in xrange(len(seq)):      for j in [[seq[i]] + x for x in permutations(seq[:i] + seq[i+1:])]:        yield j    total = 0l = ['1','2','3','4','5','6','7','8','9','0']while permute(l,10):  if has_property(''.join(l)):    total += int(''.join(l))print total